#include "msp430xG46x.h"

unsigned char *PTxData;                     // Pointer to TX data
unsigned char TXByteCtr,ConReg,WRITE=1;
unsigned int delay=0;
unsigned char TxData[] ={0xA8};              // Table of data to transmit
unsigned char RxData[3];
int R_idx;
int index = 0;
void wait(int ms);
void main(void)
{
  WDTCTL = WDTPW + WDTHOLD;                 // Stop WDT
  P3SEL |= 0x06;                            // Assign I2C pins to USCI_B0 - P3.1=SDA,P3.2=SCL
  UCB0CTL1 |= UCSWRST;                      // Enable SW reset
  UCB0CTL0 = UCMST + UCMODE_3 + UCSYNC;     // Master,I2C,synchronous mode
  UCB0CTL1 = UCSSEL_2 + UCSWRST;            // Use SMCLK, keep SW reset
  UCB0BR0 = 11;                             // fSCL = SMCLK/11 = 95.3kHz
  UCB0BR1 = 0;
  UCB0I2CSA = 0x48;                         // Slave Address is 048h
  UCB0CTL1 &= ~UCSWRST;                     // Clear SW reset, resume operation
  IE2 |= UCB0TXIE + UCB0RXIE;                           // Enable TX interrupt
  WRITE= 1;
  while (1)
  {
    if(WRITE){
       IE2 |= UCB0TXIE;
       UCB0CTL1 |= UCTR+UCTXSTT;
       //switch(index){
       //case 0:
       if (index%2==0){
                      // I2C TX, start condition
         TxData[0]=0xAC;
         index++;
       }
       else if (index%2==1){
//       case 1:
         TxData[0]=0x02;
         index++;
       }
//         break;
       //case 2:
       else  
        UCB0CTL1 |= UCTXSTP;
         //break;
         
         
       
       __bis_SR_register(CPUOFF + GIE);        // Enter LPM0 w/ interrupts

    } 
    else{ 
       
       UCB0CTL1 &= ~UCTR;
       UCB0CTL1 |= UCTXSTT;
        __bis_SR_register(CPUOFF + GIE);        // Enter LPM0 w/ interrupts
    }
                                            // Remain in LPM0 until all data
                                            // is TX'd
    
  }
}
//------------------------------------------------------------------------------
#pragma vector = USCIAB0TX_VECTOR
__interrupt void USCIAB0TX_ISR(void)
{
  if (IFG2 & UCB0TXIFG){   
    UCB0TXBUF = TxData[0];  
    IE2 &= ~UCB0TXIE;
    WRITE = 0;
    __bic_SR_register_on_exit(CPUOFF);      
  }
  else if(IFG2 & UCB0RXIFG){  
   while (UCB0CTL1 & UCTXSTT);
   RxData[R_idx] = UCB0RXBUF;
   R_idx++;
//   ConReg = UCB0RXBUF;
   WRITE = 1;
    __bic_SR_register_on_exit(CPUOFF);// Exit LPM0
  } 
}

